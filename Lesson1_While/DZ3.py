# Встречаемость элемента в массиве

# Требуется вычислить, сколько раз встречается некоторое 
# число k в массиве list_1.
# Найдите количество и выведите его.

# Пример:
# list_1 = [1, 2, 3, 4, 3]
# k = 3
# # 1
# count = 0
# for i in list_1:
#     if i == k:
#         count += 1
# print(count)

# Ближайший элемент в массиве

# Требуется найти в массиве list_1 самый близкий по величине 
# элемент к заданному числу k и вывести его.
# Считать, что такой элемент может быть только один. Если 
# значение k совпадает с этим элементом - выведите его.

# Пример:

# list_1 = [1, 2, 3, -2, -1]
# k = 6
# # 5

# closest = min(list_1, key=lambda x: abs(x - k))
# print(closest)

# Скрабл

# В настольной игре Скрабл (Scrabble) каждая буква имеет определенную ценность.

# В случае с английским алфавитом очки распределяются так:

# A, E, I, O, U, L, N, S, T, R – 1 очко;
# D, G – 2 очка;
# B, C, M, P – 3 очка;
# F, H, V, W, Y – 4 очка;
# K – 5 очков;
# J, X – 8 очков;
# Q, Z – 10 очков.
# А русские буквы оцениваются так:

# А, В, Е, И, Н, О, Р, С, Т – 1 очко;
# Д, К, Л, М, П, У – 2 очка;
# Б, Г, Ё, Ь, Я – 3 очка;
# Й, Ы – 4 очка;
# Ж, З, Х, Ц, Ч – 5 очков;
# Ш, Э, Ю – 8 очков;
# Ф, Щ, Ъ – 10 очков.
# Напишите программу, которая вычисляет стоимость введенного пользователем слова k и выводит его. Будем считать, что на вход подается только одно слово, которое содержит либо только английские, либо только русские буквы.

# Пример:


# k = 'ноутбук'
# # # 12

# def calculate_score(word):
#     english_values = {'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'L': 1, 'N': 1, 'S': 1, 'T': 1, 'R': 1,
#                       'D': 2, 'G': 2,
#                       'B': 3, 'C': 3, 'M': 3, 'P': 3,
#                       'F': 4, 'H': 4, 'V': 4, 'W': 4, 'Y': 4,
#                       'K': 5,
#                       'J': 8, 'X': 8,
#                       'Q': 10, 'Z': 10}

#     russian_values = {'А': 1, 'В': 1, 'Е': 1, 'И': 1, 'Н': 1, 'О': 1, 'Р': 1, 'С': 1, 'Т': 1,
#                       'Д': 2, 'К': 2, 'Л': 2, 'М': 2, 'П': 2, 'У': 2,
#                       'Б': 3, 'Г': 3, 'Ё': 3, 'Ь': 3, 'Я': 3,
#                       'Й': 4, 'Ы': 4,
#                       'Ж': 5, 'З': 5, 'Х': 5, 'Ц': 5, 'Ч': 5,
#                       'Ш': 8, 'Э': 8, 'Ю': 8,
#                       'Ф': 10, 'Щ': 10, 'Ъ': 10}

#     score = 0

#     for letter in word.upper():
#         if letter in english_values:
#             score += english_values[letter]
#         elif letter in russian_values:
#             score += russian_values[letter]

#     return score

# print(calculate_score(k))

# ДОП задание по желанию

# Три друга взяли вещи в поход. Сформируйте словарь, где ключ - имя друга, а значение - кортеж вещей. Ответьте на вопросы:
# какие вещи взяли все три друга - "спички"
# какие вещи уникальны, есть только у одного друга - Лиза взяла косметичку, Вася взял топор, Ваня взял еду
# какие вещи есть у всех друзей кроме одного и имя того, у кого данная вещь отсутствует - у Лизы нет спальника,
# Код должен расширяться на любое большее количество друзей.

# hike = {
# 'Вася': ("спички", "спальник", "дрова", "топор"),
# 'Ваня': ("спальник", "спички", "вода", "еда"),
# 'Лиза': ("вода", "спички", "косметичка"),
# }

hike = {
'Вася': ("спички", "спальник", "дрова", "топор"),
'Ваня': ("спальник", "спички", "вода", "еда"),
'Лиза': ("вода", "спички", "косметичка"),
}

# какие вещи взяли все три друга
# Это выражение находит пересечение множеств вещей, взятых 
# каждым другом. Оператор "&" используется для нахождения 
# общих элементов в множествах. Другими словами, это выражение 
# находит вещи, которые есть у всех трех друзей, записывая их 
# в множество common_items.
common_items = set(hike['Вася']) & set(hike['Ваня']) & set(hike['Лиза'])
print("Вещи, взятые всеми тремя друзьями:", common_items)

# какие вещи уникальны, есть только у одного друга
# Это выражение создает множество uniqueitems, которое содержит 
# только уникальные элементы из трех множеств hike['Вася'], 
# hike['Ваня'] и hike['Лиза']. В данном случае оператор ^ 
# используется для выполнения операции симметрической разности, 
# которая возвращает элементы, которые присутствуют только в 
# одном из множеств, но не в остальных. Таким образом, 
# uniqueitems будет содержать только те элементы, которые 
# присутствуют только в одном из трех исходных множеств.
unique_items = set(hike['Вася']) ^ set(hike['Ваня']) ^ set(hike['Лиза'])
print("Уникальные вещи, взятые только одним другом:", unique_items)

# какие вещи есть у всех друзей кроме одного и имя того, у кого данная вещь отсутствует
# 1. hers_items = set().union(*(v for k, v in hike.items() if k != friend))
# Это выражение создает множество hers_items, которое содержит все 
# элементы из всех списков hike, за исключением списка, связанного 
# с переменной friend. Для этого используется генераторное 
# выражение, которое проходит по всем парам ключ-значение в словаре 
# hike и объединяет все значения в одно множество. Если ключ не 
# равен переменной friend, соответствующее значение добавляется в 
# объединение. 

# 2. missing_items = set(hike[friend]) - others_items
# Это выражение создает множество missing_items, которое содержит 
# элементы из списка hike[friend], которые отсутствуют в множестве 
# others_items. Для этого используется оператор вычитания (-), 
# который возвращает все элементы из hike[friend], не входящие в 
# others_items.
for friend in hike:
    others_items = set().union(*(v for k, v in hike.items() if k != friend))
    missing_items = set(hike[friend]) - others_items
    if missing_items:
        print(f"У {friend} отсутствуют {missing_items}")